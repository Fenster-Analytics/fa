<style>
:host {
	position: relative;
	color: #FA0;
}
progress-bar-target {
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
}
status-text {
	position: absolute;
	display: grid;
	place-items: center;
	
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
}
.queued {
	background: #AA0;
}
.executing {
	background: #0A0;
}
.failed {
	background: #F00;
}
.complete {
	background: #00F;
}
</style>
<template element-type="div">
	<progress-bar-target class="complete">
		<svg width="100%" height="100%" viewBox="0 0 1 1" preserveAspectRatio="none" xmlns="http://www.w3.org/2000/svg">
			<rect x="0" y="0" width="1" height="1" fill-opacity="0.2" fill="#000" />
			<rect x="0" y="0.1" width="\{{value}}" height="0.8" fill-opacity="0.5" fill="#FFF" />
		</svg>
	</progress-bar-target>
	<status-text>
		DYNAMIC TEST: {{self.status}} \{{self.duration}} \{{data.test}}
	</status-text>
</template>
<div>
	STATIC
	Problem with getting inner html of inner templates
	since they will render incorrectly the first time, but really just want the innerHTML
	Don't want to fully render on the first pass hmmmm
	Ideally want a fully dynamic element then. Just completely re-render.
	Or use the script element hack.
	Maybe... auto convert to script element?
	That won't work, have to render before converting to script
	So, script element is the way to go, for dynamic values

	Consider a complete re-render though

	HTML template element?? Yes.
	And use template id if necessary
	Don't even have to use data-bind-template attribute
	use innerHTML
	content.textContent

	template bind to list value, should create multiple instances of the template?

	structure-data vs value... does it make sense to separate

	problem with replacing list values is there's no way to get back to the original template. So... can keep doing the #each thing,
</div>